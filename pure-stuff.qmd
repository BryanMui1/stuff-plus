---
title: "Pure Stuff"
format: pdf
---

## Pckg

```{r packages, include=FALSE}
library(tidyverse)
library(xgboost)
library(lubridate)
```

```{r}
# Path-to-data, /data/datasets.csv
data_original <- read_csv("./data/UCLA2023-2024.csv")
# The data set that we will be mutating
main <- data_original
```

## Colnames

```{r}
colnames <- as.data.frame(cbind(indx = 1:length(colnames(main)), colnames = colnames(main)))
```


## Clean the Data

```{r}
filtered_vars <- c(
    "Pitcher",
    "PitcherId",
    "TaggedPitchType",
    "RelSpeed",
    "ZoneSpeed",
    "EffectiveVelo",
    "VertBreak",
    "InducedVertBreak",
    "HorzBreak",
    "SpinRate",
    "SpinAxis",
    "RelHeight",
    "RelSide",
    "Extension",
    "VertApprAngle",
    "HorzApprAngle"
)

main %>%
  select(all_of(filtered_vars)) %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count))

main <- main %>%
  drop_na(all_of(filtered_vars))

# reorder chronologically

combine_datetime <- function(date_vec, time_vec) {
  # Parse dates
  date_parsed <- mdy(date_vec)

  # Split time strings into components
  time_parts <- strsplit(time_vec, ":")
  hour <- as.numeric(sapply(time_parts, `[`, 1))
  minute <- as.numeric(sapply(time_parts, `[`, 2))
  second <- as.numeric(sapply(time_parts, `[`, 3))

  # Calculate how many full days to add to the date
  date_shift <- floor(hour / 24)
  hour_adj <- hour %% 24

  # Create adjusted datetime
  datetime <- make_datetime(
    year = year(date_parsed),
    month = month(date_parsed),
    day = day(date_parsed) + date_shift,
    hour = hour_adj,
    min = minute,
    sec = second
  )

  return(datetime)
}

main <- main %>%
  mutate(date_parsed = combine_datetime(Date, as.character(Time)))%>%
  arrange(Date, PitchNo) %>%
  relocate(date_parsed, .after = PitchNo)
```


## CSW+ 

### Hit Quality + Play Outcome Hybrid Metric

```{r}
# Continuous function to calculate pitch quality score
# Maps contact quality from 0 (perfect contact) to 1 (whiff)
hybrid_quality <- function(PitchCall, PlayResult, ExitSpeed = NA, Angle = NA, Direction = NA) {
  # Base score from pitch/plate appearance outcome
  base_score <- case_when(
    PlayResult == "HomeRun" ~ 0,
    PitchCall %in% c("BallCalled", "BallIntentional", "BallinDirt", "HitByPitch", "Undefined") ~ 0.2,
    PitchCall %in% c("InPlay") ~ 0.3,
    PitchCall %in% c("FoulBall", "FoulBallFieldable", "FoulBallNotFieldable") ~ 0.5,
    PitchCall == "StrikeCalled" ~ 0.8,
    PitchCall == "StrikeSwinging" ~ 1,
    TRUE ~ 0.4
  )

  # Logical vector for rows with full batted-ball data
  has_contact_data <- !is.na(ExitSpeed) & !is.na(Angle) & !is.na(Direction)

  # Compute batted-ball-based contact quality for those rows
  ev_component <- pmax(0, pmin(1, (110 - ExitSpeed) / 50))
  la_component <- pmin(1, ((Angle - 17)^2) / 1600)
  horiz_component <- pmin(1, abs(Direction) / 45)
  contact_score <- 0.5 * ev_component + 0.3 * la_component + 0.2 * horiz_component

  # Combine base and contact score for rows with contact data
  final_score <- base_score
  final_score[has_contact_data] <- 0.6 * base_score[has_contact_data] + 
                                   0.4 * contact_score[has_contact_data]

  return(final_score)
}
```

### CSW+ Called Strikes Plus Whiffs% 

```{r}
# Pitcher gets a special weight if they have high CSW%
csw <- main %>%
  group_by(Pitcher) %>%
  summarise(
    csw = mean(PitchCall %in% c("StrikeCalled", "StrikeSwinging")),
    .groups = "drop"
  )
csw

# Calculate CSW%, but only after a pitcher has recorded > 10 pitches
main <- main %>%
  mutate(
    is_csw = PitchCall %in% c("StrikeCalled", "StrikeSwinging"),
    pitch_index = row_number(),
    csw_league = lag(cumsum(is_csw) / pitch_index, default = 0)  # rolling league CSW%
  ) %>%
  group_by(Pitcher) %>%
  mutate(
    pitcher_n = row_number(),  # per-pitcher index
    csw_p = lag(cumsum(is_csw) / pitcher_n, default = 0),        # rolling CSW% for pitcher
    csw_p = if_else(pitcher_n < 10, 0, csw_p)                     # apply 10-pitch min
  ) %>%
  ungroup() %>%
  mutate(
    csw_league = if_else(pitch_index < 20, 0, csw_league)         # apply 20-pitch min for league CSW
  ) %>%
  relocate(pitch_index, .before = PitchNo) %>%
  relocate(csw_league, .after = PitchCall) %>%
  relocate(pitcher_n, csw_p, .after = Pitcher)

```

### Append Metrics to data 

```{r}
csw_weight_factor <- 0.25 # contols the weight factor for CSW for pitchers

main <- main %>%
  mutate(
    csw_diff = csw_p - csw_league, 
    hybrid_quality = hybrid_quality(PitchCall, PlayResult, ExitSpeed, Angle, Direction),
    hybrid_weighted = if_else(
      csw_p == 0 | csw_league == 0,  # early pitchers — don't modify
      hybrid_quality,
      hybrid_quality * (1 + csw_weight_factor * csw_diff)),
    hybrid_weighted = pmin(pmax(hybrid_weighted, 0), 1)
    ) %>% 
  relocate(hybrid_quality, hybrid_weighted, .after = PitchCall)
```


## Apply Normalizations

## Training Models


```{r}
# Select the variables we need, refer the beginning to see which variables are being selected
# vars <- c(
#     "Pitcher",
#     "PitcherId",
#     "TaggedPitchType",
#     "RelSpeed",
#     "ZoneSpeed",
#     "EffectiveVelo",
#     "VertBreak",
#     "InducedVertBreak",
#     "HorzBreak",
#     "SpinRate",
#     "SpinAxis",
#     "RelHeight",
#     "RelSide",
#     "Extension",
#     "VertApprAngle",
#     "HorzApprAngle",
#     "hitCSW",
#     "hitCSW_resid"
# )
# 
# data_filtered <- data %>%
#   select(all_of(vars))

# Now to partition separate datasets for all the pitch types
data_partitioned <- list()

data_partitioned[["Fastball"]] <- main %>%
  filter(TaggedPitchType == "Fastball" | TaggedPitchType == "FourSeamFastBall" | TaggedPitchType == "OneSeamFastBall")
data_partitioned[["Curveball"]] <- main %>%
  filter(TaggedPitchType == "Curveball")
data_partitioned[["Slider"]] <- main %>%
  filter(TaggedPitchType == "Slider")
data_partitioned[["ChangeUp"]] <- main %>%
  filter(TaggedPitchType == "ChangeUp")
data_partitioned[["Sinker"]] <- main %>%
  filter(TaggedPitchType == "Sinker")

print(data_partitioned)
```



Training Models

```{r}
# Model Variables used to predict Y, feel free to change
model_vars <- c(
    "RelSpeed", # Speed of ball at release
    "ZoneSpeed", # Speed of ball at the plate
    "EffectiveVelo", # Perceived pitch speed by the batter
    "VertBreak", # Full vertical break
    "InducedVertBreak", # Vertical break solely by the pitch(without the movement from gravity)
    "HorzBreak",
    "SpinRate",
    "SpinAxis", # spin axis from 0-360 degrees
    "RelHeight", # Vertical distance of the ball above home plate when the pitcher releases the balls
    "RelSide", # Distance from the y-axis from which the pitcher releases the ball
    "Extension", # Distance towards home plate from which the pitcher releases the ball relative to the pitching rubber
    "VertApprAngle", # Vertical Approach Angle - The vertical angle formed by the intersection of the y-axis and the ball’s path (in the z-direction) as it crosses the front of home plate. (Degrees)
    "HorzApprAngle" # Horizontal Approach Angle - The horizontal angle formed by the intersection of the y-axis and the ball’s path (in the x-direction) as it crosses the front of home plate (Degrees)
)

# get the LM equation formatted
equation <- paste("hybrid_weighted ~ ", paste(model_vars, collapse = " + "))
# print(equation)

# fit the model, predict stuff+ and standardize to 100
lms <- list()
stuff_plus <- list()
for(i in attr(data_partitioned, "names")) {
  cat(i, "Model: \n")
  lms[[i]] <- lm(formula(equation), data = data_partitioned[[i]])
  print(summary(lms[[i]]))
  cat("-------------------------------------------------------------------------------------\n")
  stuff_plus[[i]] <- data_partitioned[[i]] %>%
    mutate(
      raw_stuff = predict(lms[[i]], newdata = .),
      StuffPlus = 100 * raw_stuff / mean(raw_stuff, na.rm = TRUE)
    )
}
```