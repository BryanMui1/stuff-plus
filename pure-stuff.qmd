---
title: "Pure Stuff"
format: pdf
---

## Pckg

```{r packages, include=FALSE}
library(tidyverse)
library(xgboost)
library(lubridate)
library(ggplot2)
library(ggcorrplot)
```

```{r}
# Path-to-data, /data/datasets.csv
data_original <- read_csv("./data/UCLA2023-2024.csv")
# The data set that we will be mutating
main <- data_original
```

## Colnames

```{r}
colnames <- as.data.frame(cbind(indx = 1:length(colnames(main)), colnames = colnames(main)))
```


## Clean the Data

```{r}
filtered_vars <- c(
  "Pitcher",
  "PitcherId",
  "TaggedPitchType",
  "RelSpeed",           # Speed at release
  "ZoneSpeed",          # Speed at the plate
  "EffectiveVelo",      # Perceived pitch speed
  "VertBreak",          # Full vertical break
  "InducedVertBreak",   # Break excluding gravity
  "HorzBreak",          # Horizontal movement
  "SpinRate",           # Raw spin
  "SpinAxis",           # 0–360 spin axis
  "RelHeight",          # Release height
  "RelSide",            # Horizontal release side
  "Extension",          # Distance toward plate
  "VertApprAngle",      # Vertical approach angle
  "HorzApprAngle",      # Horizontal approach angle
  "VertRelAngle",       # Vertical release angle
  "HorzRelAngle",       # Horizontal release angle
  "Tilt",               # Spin tilt
  "PlateLocHeight",     # Raw vertical location
  "PlateLocSide",       # Raw horizontal location
  "ZoneTime",           # Time to reach plate
  "SpeedDrop"           # Velo loss from release to plate
)

main %>%
  select(all_of(filtered_vars)) %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count))

main <- main %>%
  drop_na(all_of(filtered_vars))

main <- main %>%
  mutate(date_parsed = combine_datetime(Date, as.character(Time)))%>%
  arrange(UTCDateTime, PitchNo) %>%
  relocate(date_parsed, .after = PitchNo)
```


## CSW+ 

### Hit Quality + Play Outcome Hybrid Metric

```{r}
# Continuous function to calculate pitch quality score
# Maps contact quality from 0 (perfect contact) to 1 (whiff)
hybrid_quality <- function(PitchCall, PlayResult, ExitSpeed = NA, Angle = NA, Direction = NA) {
  # Base score from pitch/plate appearance outcome
  base_score <- case_when(
    PlayResult == "HomeRun" ~ 0,
    PitchCall %in% c("BallCalled", "BallIntentional", "BallinDirt", "HitByPitch", "Undefined") ~ 0.2,
    PitchCall %in% c("InPlay") ~ 0.3,
    PitchCall %in% c("FoulBall", "FoulBallFieldable", "FoulBallNotFieldable") ~ 0.5,
    PitchCall == "StrikeCalled" ~ 0.8,
    PitchCall == "StrikeSwinging" ~ 1,
    TRUE ~ 0.4
  )

  # Logical vector for rows with full batted-ball data
  has_contact_data <- !is.na(ExitSpeed) & !is.na(Angle) & !is.na(Direction)

  # Compute batted-ball-based contact quality for those rows
  ev_component <- pmax(0, pmin(1, (110 - ExitSpeed) / 50))
  la_component <- pmin(1, ((Angle - 17)^2) / 1600)
  horiz_component <- pmin(1, abs(Direction) / 45)
  contact_score <- 0.5 * ev_component + 0.3 * la_component + 0.2 * horiz_component

  # Combine base and contact score for rows with contact data
  final_score <- base_score
  final_score[has_contact_data] <- 0.6 * base_score[has_contact_data] + 
                                   0.4 * contact_score[has_contact_data]

  return(final_score)
}
```

### CSW+ Called Strikes Plus Whiffs% 

```{r}
# Pitcher gets a special weight bonus if they have high CSW%, if they have low CSW% they get a penalty
csw <- main %>%
  group_by(Pitcher) %>%
  summarise(
    csw = mean(PitchCall %in% c("StrikeCalled", "StrikeSwinging")),
    .groups = "drop"
  )
csw

# Calculate CSW%, but only after a pitcher has recorded > 10 pitches
main <- main %>%
  mutate(
    is_csw = PitchCall %in% c("StrikeCalled", "StrikeSwinging"),
    pitch_index = row_number(),
    csw_league = lag(cumsum(is_csw) / pitch_index, default = 0)  # rolling league CSW%
  ) %>%
  group_by(Pitcher) %>%
  mutate(
    pitcher_n = row_number(),  # per-pitcher index
    csw_p = lag(cumsum(is_csw) / pitcher_n, default = 0),        # rolling CSW% for pitcher
    csw_p = if_else(pitcher_n < 10, 0, csw_p)                     # apply 10-pitch min
  ) %>%
  ungroup() %>%
  mutate(
    csw_league = if_else(pitch_index < 20, 0, csw_league)         # apply 20-pitch min for league CSW
  ) %>%
  relocate(pitch_index, pitcher_n, .before = PitchNo) %>%
  relocate(csw_p, csw_league, .after = PitchCall)
```

### Append Metrics to data 

```{r}
csw_weight_factor <- 0.25 # controls the weight factor for CSW for pitchers

main <- main %>%
  mutate(
    csw_diff = csw_p - csw_league, 
    hybrid_quality = hybrid_quality(PitchCall, PlayResult, ExitSpeed, Angle, Direction),
    hybrid_weighted = if_else(
      csw_p == 0 | csw_league == 0,  # early pitchers — don't modify
      hybrid_quality,
      hybrid_quality * (1 + csw_weight_factor * csw_diff)),
    hybrid_weighted = pmin(pmax(hybrid_weighted, 0), 1)
    ) %>% 
  relocate(hybrid_quality, hybrid_weighted, .after = PitchCall)
```


## Apply Normalizations

```{r}
# One hot encode, batterside, count(balls and strikes), PAofinning, inning, outs
main <- main %>%
  mutate(Count = factor(paste0(Balls, "-", Strikes))) %>%
  mutate(
    BatterSide = factor(BatterSide),
    PAofInning = factor(PAofInning),
    Inning = factor(Inning),
    Outs = factor(Outs)
  )

one_hot_matrix <- model.matrix(
  ~ BatterSide + Count + PAofInning + Inning + Outs - 1,  # "-1" removes intercept
  data = main
)

# Convert matrix to a data frame
one_hot_df <- as.data.frame(one_hot_matrix)

# Combine with your original dataset
main <- cbind(main, one_hot_df)

```




```{r}
# Model Variables used to predict Y, feel free to change

# model_vars <- c(
#   "RelSpeed",           # Speed at release
#   "ZoneSpeed",          # Speed at the plate
#   "EffectiveVelo",      # Perceived pitch speed
#   "VertBreak",          # Full vertical break
#   "InducedVertBreak",   # Break excluding gravity
#   "HorzBreak",          # Horizontal movement
#   "SpinRate",           # Raw spin
#   "SpinAxis",           # 0–360 spin axis
#   "RelHeight",          # Release height
#   "RelSide",            # Horizontal release side
#   "Extension",          # Distance toward plate
#   "VertApprAngle",      # Vertical approach angle
#   "HorzApprAngle",      # Horizontal approach angle
#   "VertRelAngle",       # Vertical release angle
#   "HorzRelAngle",       # Horizontal release angle
#   "PlateLocHeight",     # Raw vertical location
#   "PlateLocSide",       # Raw horizontal location
#   "ZoneTime",           # Time to reach plate
#   "SpeedDrop"           # Velo loss from release to plate
# )

model_vars <- c(
  # Physical pitch characteristics
  "RelSpeed", "ZoneSpeed", "EffectiveVelo",
  "VertBreak", "InducedVertBreak", "HorzBreak",
  "SpinRate", "SpinAxis",
  "RelHeight", "RelSide", "Extension",
  "VertApprAngle", "HorzApprAngle",
  "VertRelAngle", "HorzRelAngle",
  "PlateLocHeight", "PlateLocSide",
  "ZoneTime", "SpeedDrop"
  
  # # Count (one-hot)
  # "Count0-1", "Count0-2", "Count1-0", "Count1-1", "Count1-2",
  # "Count2-0", "Count2-1", "Count2-2", "Count3-0", "Count3-1", "Count3-2",
  # 
  # # PA of inning (one-hot)
  # "PAofInning2", "PAofInning3", "PAofInning4", "PAofInning5",
  # "PAofInning6", "PAofInning7", "PAofInning8", "PAofInning9",
  # "PAofInning10", "PAofInning11", "PAofInning12", "PAofInning13",
  # "PAofInning14", "PAofInning15", "PAofInning16",
  # 
  # # Inning (one-hot)
  # "Inning2", "Inning3", "Inning4", "Inning5", "Inning6",
  # "Inning7", "Inning8", "Inning9", "Inning10", "Inning11",
  # "Inning12", "Inning13",
  # 
  # # Outs (one-hot)
  # "Outs1", "Outs2", "Outs3"
)
```

## Visualizations

```{r}
ggplot(main, aes(x = hybrid_weighted)) +
  geom_density(fill = "steelblue", alpha = 0.6) +
  labs(
    title = "Density of Weighted Pitch Quality",
    x = "Weighted Pitch Quality",
    y = "Density"
  ) +
  theme_minimal()

ggplot(main, aes(x = csw_p)) +
  geom_density(fill = "steelblue", alpha = 0.6) +
  labs(
    title = "Density of CSW",
    x = "Weighted Pitch Quality",
    y = "Density"
  ) +
  theme_minimal()
```


```{r}
model_vars_data <- main %>%
  select(all_of(model_vars))

cor_matrix <- cor(model_vars_data, use = "complete.obs")

# pairs(model_vars_data)
#ggcorrplot(model_vars_data, lab = TRUE)
```

```{r}
colnames <- as.data.frame(cbind(indx = 1:length(colnames(main)), colnames = colnames(main)))
```


## Training Models


```{r}
# Now to partition separate datasets for all the pitch types
data_partitioned <- list()

data_partitioned[["Fastball"]] <- main %>%
  filter(TaggedPitchType == "Fastball" | TaggedPitchType == "FourSeamFastBall" | TaggedPitchType == "OneSeamFastBall")
data_partitioned[["Curveball"]] <- main %>%
  filter(TaggedPitchType == "Curveball")
data_partitioned[["Slider"]] <- main %>%
  filter(TaggedPitchType == "Slider")
data_partitioned[["ChangeUp"]] <- main %>%
  filter(TaggedPitchType == "ChangeUp")
data_partitioned[["Sinker"]] <- main %>%
  filter(TaggedPitchType == "Sinker")
```



Training Models

```{r}
# get the LM equation formatted
equation <- paste("hybrid_weighted ~ ", paste(model_vars, collapse = " + "))
# print(equation)

# fit the model, predict stuff+ and standardize to 100
lms <- list()
stuff_plus <- list()
for(i in attr(data_partitioned, "names")) {
  cat(i, "Model: \n")
  lms[[i]] <- lm(formula(equation), data = data_partitioned[[i]])
  print(summary(lms[[i]]))
  cat("-------------------------------------------------------------------------------------\n")
  stuff_plus[[i]] <- data_partitioned[[i]] %>%
    mutate(
      raw_stuff = predict(lms[[i]], newdata = .),
      StuffPlus = 100 * raw_stuff / mean(raw_stuff, na.rm = TRUE)
    )
}
```

```{r}
main %>%
  select(model_vars) %>%
  summarise(across(everything(), ~sum(is.na(.)))) %>%
  pivot_longer(everything(), names_to = "column", values_to = "na_count") %>%
  arrange(desc(na_count))

```

