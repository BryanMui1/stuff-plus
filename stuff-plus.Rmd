---
title: "stuff-plus"
author: "Bryan Mui - UID 506021334"
date: "2025-03-05"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Library packages

```{r packages, include=FALSE}
library(tidyverse)
library(xgboost)
```

# Read the dataset

```{r}
data_original <- read_csv("./data/UCLA2023-2024.csv")
# The data set that we will be mutating
data <- data_original
head(data, 25)
```


# Outputting the columns

```{r}
colnames(data)
```

Predictor Ideas:

Velocity:

    * RelSpeed (Release Speed)
    * ZoneSpeed (Speed at the plate)
    * EffectiveVelo (Velocity adjusted for approach angle)

Movement:

    * VertBreak (Vertical movement due to spin)
    * InducedVertBreak (More refined vertical movement measurement)
    * HorzBreak (Horizontal movement due to spin)
    * pfxx (Horizontal movement component)
    * pfxz (Vertical movement component)

Spin:

    * SpinRate (Total revolutions per minute)
    * SpinAxis (2D spin direction)
    * SpinAxis3dTransverseAngle (3D spin components)
    * SpinAxis3dLongitudinalAngle
    * SpinAxis3dActiveSpinRate
    * SpinAxis3dSpinEfficiency

Release & Extension:

    * RelHeight (Height of release)
    * RelSide (Side angle of release)
    * Extension (How far forward the pitcher releases the ball)

Pitch Type & Classification:

    * TaggedPitchType (Human-classified pitch type)
    * AutoPitchType (Algorithm-classified pitch type)

Location & Trajectory (Optional, but can improve Stuff+ models):

    * PlateLocHeight (Height of the pitch as it crosses the plate)
    * PlateLocSide (Side location at home plate)
    * VertApprAngle (Vertical approach angle)
    * HorzApprAngle (Horizontal approach angle)
    
    
**For now, focusing on these variables:**

    * Pitch Velocity
    * Vertical Break
    * Horizontal Break 
    * Arm Angle 
    * Release Extension
    
    
# Stuff+ 

## Part 1: Exploring Pitch Types and Sectioning Data Based off Pitches

```{r}
data %>% 
  group_by(TaggedPitchType) %>%
  summarize(Count = n())
```
We can see that we have ample data to produce a model for 1) Fastball, 2) Curve Ball, 3) Change Up, 4) Slider, 5) Sinker. The rest of the pitches have limited observations

```{r}
# Section the Data based off pitch type(Run After we've transformed variables)
# data_fastball <- data %>%
#   filter(TaggedPitchType == "Fastball")
# data_curveball <- data %>%
#   filter(TaggedPitchType == "Curveball")
# data_changeup <- data %>%
#   filter(TaggedPitchType == "ChangeUp")
# data_slider <- data %>%
#   filter(TaggedPitchType == "Slider")
# data_sinker <- data %>%
#   filter(TaggedPitchType == "Sinker")
```

    
## Part 2: Target Variable(set hit = 0/not a hit = 1)

```{r}
# Calculate hit/no-hit on pitch
data <- data %>%
  mutate(hit_response = ifelse(PlayResult != "Undefined", 1, 0)) %>%
  relocate(hit_response, .after = PitchCall)
```

    
    
## Part 3: Calculating Stuff+

```{r}
# Select the variables we need, refer the beginning to see which variables are being selected
vars <- c(
    "Pitcher",
    "PitcherId",
    "TaggedPitchType",
    "RelSpeed",
    "ZoneSpeed",
    "EffectiveVelo",
    "VertBreak",
    "InducedVertBreak",
    "HorzBreak",
    "SpinRate",
    "SpinAxis",
    "Tilt",
    "RelHeight",
    "RelSide",
    "Extension",
    "VertApprAngle",
    "HorzApprAngle",
    "hit_response"
)

data <- data %>%
  select(all_of(vars))

# Now create separate datasets for all the pitch types
# Section the Data based off pitch type(Run After we've transformed variables)
data_fastball <- data %>%
  filter(TaggedPitchType == "Fastball")
data_curveball <- data %>%
  filter(TaggedPitchType == "Curveball")
data_changeup <- data %>%
  filter(TaggedPitchType == "ChangeUp")
data_slider <- data %>%
  filter(TaggedPitchType == "Slider")
data_sinker <- data %>%
  filter(TaggedPitchType == "Sinker")
```

Misc Code Chunks: 
```{r}
# Calculate team-wide SD and mean for metrics
# means <- stuff_data %>%
#   group_by("TaggedPitchType") %>%
#   summarise_all(funs(mean), na.rm = TRUE)
# means
# 
# sds <- stuff_data %>%
#   group_by("TaggedPitchType") %>%
#   summarise_all(funs(sd), na.rm = TRUE)
# means
```

```{r}
# stuff_data_standardized <- stuff_data %>%
#   group_by("TaggedPitchType") %>%
#   mutate_at(vars(RelSpeed:swstr_percent), scale) %>%
#   drop_na()
# 
# stuff_data_standardized
```


### Part 3a: Calculating Coefficients Using LM

Fastball Model

```{r}
model_vars <- c(
    "RelSpeed",
    "ZoneSpeed",
    "EffectiveVelo",
    "VertBreak",
    "InducedVertBreak",
    "HorzBreak",
    "SpinRate",
    "SpinAxis",
    "Tilt",
    "RelHeight",
    "RelSide",
    "Extension",
    "VertApprAngle",
    "HorzApprAngle"
)

# get the LM equation formatted
equation <- paste("hit_response ~ ", paste(model_vars, collapse = " + "))
print(equation)

# train
lm_fb <- lm(formula(equation), data = data_fastball)

# summarize
summary(lm_fb)

# standardize stuff to 100
stuff_fb <- data_fastball %>%
  mutate(
    raw_stuff = predict(lm_fb, newdata = .),
    StuffPlus = 100 * raw_stuff / mean(raw_stuff, na.rm = TRUE)
  )
```

Ranking Top 50 Pitches Given by Stuff Plus

```{r}
top_50 <- stuff_fb %>%
  top_n(50, StuffPlus)

head(top_50, 50)
```




Misc Code Chunks
```{r}
# xgb_fb <- xgboost(
#   data = X,
#   label = y,
#   objective = "binary:logistic",
#   nrounds = 100,
#   verbose = 0
# )
# 
# importance <- xgb.importance(model = xgb_model)
# xgb.plot.importance(importance)
# model <- lm(swstr_percent ~ RelSpeed + ZoneSpeed + EffectiveVelo +
#             VertBreak + InducedVertBreak + HorzBreak +
#             pfxx + pfxz + SpinRate + SpinAxis +
#             RelHeight + RelSide + Extension +
#             PlateLocHeight + PlateLocSide +
#             VertApprAngle + HorzApprAngle,
#             data = stuff_data_standardized)
# 
# summary(model)
# model$coefficients
```


```{r}
# # Calculate Stuff+
# coefficients <- coef(model)
# 
# 
# 
# stuff_plus_calc <- stuff_data_standardized %>%
#     rowwise() %>%
#     mutate(stuff_plus = coefficients["(Intercept)"] +
#                       coefficients["RelSpeed"] * RelSpeed +
#                       coefficients["ZoneSpeed"] * ZoneSpeed +
#                       coefficients["EffectiveVelo"] * EffectiveVelo +
#                       coefficients["VertBreak"] * VertBreak +
#                       coefficients["InducedVertBreak"] * InducedVertBreak +
#                       coefficients["HorzBreak"] * HorzBreak +
#                       coefficients["pfxx"] * pfxx +
#                       coefficients["pfxz"] * pfxz +
#                       coefficients["SpinRate"] * SpinRate +
#                       coefficients["SpinAxis"] * SpinAxis +
#                       coefficients["RelHeight"] * RelHeight +
#                       coefficients["RelSide"] * RelSide +
#                       coefficients["Extension"] * Extension +
#                       coefficients["PlateLocHeight"] * PlateLocHeight +
#                       coefficients["PlateLocSide"] * PlateLocSide +
#                       coefficients["VertApprAngle"] * VertApprAngle +
#                       coefficients["HorzApprAngle"] * HorzApprAngle)
# 
# stuff_plus_calc
```


# Misc

## Stuff++ 

We could use a non-linear model to calculate Stuff+ but it would be a black-box model, meaning it gives us a score with no interpretable coefficients. The model might have better performance but low interpretability, hence we only know what the stuff is but we don't know what actually affects stuff
